<?php
/**
 * @ver 1.0
 * @order 10
 */
class imdb {
  private $core;
  
  public function __construct() {
    global $core;

    $this->core = $core;
    $this->core->defines('LOADED_IMDB', true);
  }
  
  public function load_by_id($id = false) {
    if ($id) {
      $found = $this->core->select('*', 'items', array('id' => $id));
      if ($found) {
        return $found;
      }
      return $this->core->error("ID: ".$id." Not Found");
    }
    return $this->core->error("Cannot Load Blank ID");
  }

  public function load_by_title($title = false, $type = false) {
    if ($title) {
      if ($type) {
        $found = $this->core->select('*', 'items', array('title' => $title, 'type' => $type));
        if ($found) {
          return $found;
        }
        return $this->core->error("Title: ".$title." Not Found");
      }
      return $this->core->error("Type Is Blank");
    }
    return $this->core->error("Cannot Load Blank Title");
  }

  public function get_imdb($title = false, $year = false, $type = false) {
    if ($title) {
      $_imdb_by_title = $this->get_imdb_data($title, $year, $type);
      if ($_imdb_by_title) {
        $found = $this->core->select('*', 'items', array('title' => $_imdb_by_title->title, 'year' => $_imdb_by_title->year, 'type' => $_imdb_by_title->type));
        if (!$found) {
          $insert_fields = $this->core->clean_insert($this->core->object_to_array($_imdb_by_title), array('img_orig', 'img_new', 'genre'));
          $items_id = $this->core->insert('items', $insert_fields);
          if ($items_id) {
            if ($_imdb_by_title->genre) {
              foreach ($_imdb_by_title->genre as $key => $genre) {
                $found = $this->core->select('*', 'genre', array('name' => $genre));
                if (!$found) {
                  $genre_id = $this->core->insert('genre', array('name' => $genre));
                } else {
                  $found_key = array_keys($this->core->object_to_array($found));
                  $genre_id = $found_key[0];
                }

                if ($genre_id) {
                  $found = $this->core->select('*', 'rel_genre', array('items_id' => $items_id, 'genre_id' => $genre_id));
                  if (!$found) {
                    $rel_genre_id = $this->core->insert('rel_genre', array('items_id' => $items_id, 'genre_id' => $genre_id));
                  }
                }
              }
            }
            if ($type == 'series') {
              $this->update_imdb_episodes($items_id);
            }
          }
        }
        return $found;
      }
      return false;
    }
    return $this->core->error("Cannot Find Blank Title");
  }
  
  private function get_imdb_data($title = false, $year = false, $type = false) {
    if ($title) {
      $url = $this->core->_links->imdb_search.urlencode($title);
      if ($year) {
        $url .= '&release_date='.$year;
      }
      if ($type) {
        $url .= '&title_type=';
        switch($type) {
          case 'movie':
            $url .= 'feature,tv_movie,video,unknown,short,documentary,game';
          break;
          case 'series':
            $url .= 'tv_series,mini_series,tv_special,video,unknown';
          break;
        }
      }
      $ch = curl_init($url);
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
      curl_setopt($ch, CURLOPT_NOSIGNAL, 1);
      $data = curl_exec($ch);
      $curl_errno = curl_errno($ch);
      $curl_error = curl_error($ch);
      curl_close($ch);
      
      if ($curl_errno > 0) {
        return $this->core->error("There Was An Error(".$curl_errno."): ".$curl_error);
      }
      $newData = $this->format_imdb_data($data, $type);

      if ($newData) {
        return $newData;
      }
      return $this->core->error("Could Not Find Title");
    }
    return $this->core->error("Cannot Find Blank Name");
  }

  private function get_imdb_episodes($imdb_data = false) {
    if ($imdb_data) {
      if ($imdb_data->type == 'series') {
        if ($imdb_data->link) {
          $url = $this->core->_links->imdb_title.$imdb_data->link.$this->core->_links->imdb_episodes;
          $ch = curl_init($url);
          curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
          curl_setopt($ch, CURLOPT_NOSIGNAL, 1);
          $data = curl_exec($ch);
          $curl_errno = curl_errno($ch);
          $curl_error = curl_error($ch);
          curl_close($ch);

          if ($curl_errno > 0) {
            return $this->core->error("There Was An Error(".$curl_errno."): ".$curl_error);
          }
          $newData = $this->format_imdb_data_episodes($data);

          if ($newData) {
            return $newData;
          }
          return $this->core->error("Could Not Find Episodes");
        }
        return $this->core->error("Could Not Find Link");
      }
      return $this->core->error("This Feature Is For Series Only");
    }
    return $this->core->error("Data Empty");
  }

  public function update_imdb_episodes($items_id = false) {
    if ($items_id) {
      $found = $this->core->select('*', 'items', array('id' => $items_id, 'type' => 'series'));
      if ($found) {
        $_imdb_episodes = $this->get_imdb_episodes($this->core->single($found));
        if ($_imdb_episodes) {
          foreach($_imdb_episodes as $_imdb_episode) {
            $found = $this->core->select('*', 'series', array('items_id' => $items_id, 'season' => $_imdb_episode->season, 'episode' => $_imdb_episode->episode));
            if (!$found) {
              $_imdb_episode->items_id = $items_id;
              $episode_id = $this->core->insert('series', $this->core->object_to_array($_imdb_episode));
            } else {
              $episode = $this->core->single($found);
              if ($episode->name != $_imdb_episode->name || $episode->description != $_imdb_episode->description || $episode->date != $_imdb_episode->date) {
                $this->core->update('series', array('name' => $_imdb_episode->name, 'description' => $_imdb_episode->description, 'date' => $_imdb_episode->date), array('id' => $episode->id));
              }
            }
          }
          return true;
        }
        return $this->core->error("No Episodes Found");
      }
      return $this->core->error("Cannot Find Item");
    }
    return $this->core->error("Cannot Update Blank Item");
  }
  
  private function format_imdb_data($data = false, $type = false) {
    if ($data) {
      $dataObj = false;
      $newData = $this->core->parse('<tr class="even detailed">', '</tr>', $data);
      if ($newData) {
        $newData = str_replace(array("\n", "\r"), "", $newData);
        $dataObj->img_orig = $this->core->parse('<td class="image">', '</td>', $newData);
        $dataObj->img_orig = $this->core->parse('src="', '"', $newData);
        $dataObj->img_new = preg_replace('/(_V)(.)(\._)(.[^\.]*)/', '$1$2$3SX250_CR0,0,250,370_', $dataObj->img_orig);
        $newData = $this->core->parse('<td class="title">', '</td>', $newData);
        $dataObj->title = $this->core->parse('">', '', $this->core->parse('<a href="/title/', '</a>', $newData));
        $dataObj->link = $this->core->parse('<a href="/title/', '/"', $newData);
        $dataObj->year = preg_replace("/(\()([0-9]*)(.*)/", "$2", $this->core->parse('<span class="year_type">', '</span>', $newData));
        $dataObj->rating = $this->core->parse('<span class="value" itemprop="ratingValue">', '</span>', $newData);
        $dataObj->story = $this->core->parse('<span class="outline">', '</span>', $newData);
        $dataObj->genre = explode(" | ", strip_tags($this->core->parse('<span class="genre">', '</span>', $newData)));
        $dataObj->certificate = $this->core->parse('title="', '"', $this->core->parse('<span class="certificate">', '</span>', $newData));
        $dataObj->type = $type;
      
        if ($dataObj->link && $dataObj->img_orig && $dataObj->img_new) {
          $this->core->save_img($dataObj->img_orig, $dataObj->link."_thumb.jpg");
          $this->core->save_img($dataObj->img_new, $dataObj->link."_full.jpg");
        }
      }
      return $dataObj;
    }
    return $this->core->error("Invalid Data");
  }

  private function format_imdb_data_episodes($data = false) {
    if (defined('PLUGIN_PHPQUERY')) {
      if ($data) {
        $phpQuery = phpQuery::newDocumentHTML($data);
        if (count($phpQuery['.season-filter-all']) > 0) {
          $seriesInfo = array();
          foreach ($phpQuery['.season-filter-all'] as $season) {
            $seasonNumber = str_ireplace(array("\n", "\r", "season", " "), "", pq($season)->find('.season-header')->html());
            if (is_numeric($seasonNumber)) {
              foreach (pq($season)->find('.filter-all') as $episode) {
                $episodeInfo = pq($episode)->find('h3');
                preg_match('/(, .[^:]*)/', $episodeInfo->remove('a')->html(), $episodeNumber);
                $episodeNumber = str_ireplace(array("episode", " ", ","), "", $episodeNumber[0]);
                $episodeName = $episodeInfo->find('a')->html();
                $episodeInfo = pq($episode)->find('td');
                $episodeInfo->find('h3,div')->remove();
                $episodeInfo = explode("<br>", $episodeInfo->html());
                $episodeDescription = trim(strip_tags($episodeInfo[1]));
                $episodeDate = strtotime(pq($episodeInfo[0])->find('strong')->html());
                $seriesInfo[] = array(
                  'season' => $seasonNumber,
                  'episode' => $episodeNumber,
                  'name' => $episodeName,
                  'description' => $episodeDescription,
                  'date' => $episodeDate
                );
              }
            }
          }
          if (count($seriesInfo) > 0) {
            return $this->core->array_to_object($seriesInfo);
          }
          return $this->core->error("Bad Data");
        }
        return $this->core->error("No Seasons Found");
      }
      return $this->core->error("Invalid Data");
    }
    return $this->core->error("Missing Plugin: phpQuery");
  }
}
?>