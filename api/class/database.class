<?php
/**
 * @ver 1.0
 * @order 30
 */
class database extends security {
  private $_db = false;
  private $_schema;
  private $_schema_bak;
  
  public function __construct() {
    parent::__construct();
    $this->defines('LOADED_DATABASE', true);
  }

  public function set_schema($schema = false) {
    if ($schema) {
      if (file_exists($this->_files->db.$schema.'.db')) {
        $this->_schema = $schema.'.db';
        $this->_schema_bak = BAKUP_DATE.'_'.$schema.'.db.bak';
        
        return $this;
      }
      return false;
    }
    return false;
  }
  
  public function open() {
    if (file_exists($this->_files->db.$this->_schema)) {
      require_once "DB.php";
      require_once "DB/sqlite.php";
      $dbd = array(
        'phptype'  => 'sqlite3',
        'database' => $this->_files->db.$this->_schema,
        'mode'     => '0644',
      );
      $this->_db =& DB::connect($dbd);
      if (PEAR::isError($this->_db)) {
        return $this->error($this->_db->getMessage());
      } else {
        $this->backup();
        return true;
      }
    }
    return $this->error('Schema Not Found');
  }

  private function backup() {
    copy($this->_files->db.$this->_schema, $this->_files->db_bak);
    $d = dir(dirname($this->_files->db.$this->_schema));
    $backups = array();
    while (false !== ($entry = $d->read())) {
      if (!in_array($entry, array('.', '..'))) {
        if (substr($entry, -3) == 'bak') {
          if (count($backups) >= BACKUP_LIMIT) {
            unlink($backups[count($backups)-BACKUP_LIMIT]);
          }
          $backups[] = dirname($this->_files->db.$this->_schema).'/'.$entry;
        }
      }
    }
    $d->close();
  }
  
  public function execute($query = false) {
    if ($query) {
      $sql =& $this->_db->query($query);
      if (PEAR::isError($sql)) {
        return $this->error($sql->getMessage()." :: ".$query);
      } else {
        $result = array();
        while ($sql->fetchInto($row, DB_FETCHMODE_ASSOC)) {
          $result[] = $row;
        }
        $sql->free();

        return $this->array_to_object($result);
      }
    }
    return $this->error('Missing SQL Statement');
  }

  public function select($columns, $table, $where = false, $order = false, $limit = false) {
    if (isset($this->_db)) {
      $columns = is_array($columns) ? implode(',', $columns) : $columns;
      if ($where && is_array($where) && count($where)) {
        $build = " WHERE ";
        foreach($where as $key => $val) {
          if ($build != " WHERE ") {
            $build .= " AND ";
          }
          $build .= $key." = '".str_replace("'", "&#44;", $val)."'";
        }
        $where = $build;
      } else {
        $where = '';
      }
      if ($order && is_array($order) && count($order)) {
        $build = " ORDER BY ";
        foreach($order as $key => $val) {
          if ($build != " ORDER BY ") {
            $build .= ", ";
          }
          $build .= $key." ".$val;
        }
        $order = $build;
      } else {
        $order = '';
      }
      $limit = ($limit) ? " LIMIT ".$limit : '';

      return $this->execute("SELECT $columns FROM $table $where $order $limit");
    }
    return $this->error('DB Not Loaded');
  }

  public function insert($table, $fields) {
    if (isset($this->_db)) {
      if (is_array($fields) && count($fields)) {
        foreach($fields as $key => $val) {
          $fields[$key] = "'".str_replace("'", "&#44;", $val)."'";
        }
        $result = $this->execute("INSERT INTO $table (".implode(',', array_keys($fields)).") VALUES (".implode(',', array_values($fields)).")");
        if ($result) {
          return $this->_db->lastInsertRowID();
        }
        return false;
      }
      return $this->error('Invalid Fields');
    }
    return $this->error('DB Not Loaded');
  }
  
  public function update($table, $fields, $where = false) {
    if (isset($this->_db)) {
      if (is_array($fields) && count($fields)) {
        $with = " SET ";
        foreach($fields as $key => $val) {
          if ($with != " SET ") {
            $with .= ", ";
          }
          $with .= $key." = ".$val;
        }
        if ($where && is_array($where) && count($where)) {
          $build = " WHERE ";
          foreach($where as $key => $val) {
            if ($build != " WHERE ") {
              $build .= " AND ";
            }
            $build .= $key." = '".str_replace("'", "&#44;", $val)."'";
          }
          $where = $build;
        } else {
          $where = '';
        }
        return $this->execute("UPDATE $table $with $where");
      }
      return $this->error('Invalid Fields');
    }
    return $this->error('DB Not Loaded');
  }

  public function clean_insert($insert_fields, $clean = array()) {
    if (count($clean)) {
      foreach($clean as $key => $val) {
        if (is_array($insert_fields)) {
          unset($insert_fields[$val]);
        }
        if (is_object($insert_fields)) {
          unset($insert_fields->$val);
        }
      }
    }

    return $insert_fields;
  }

  public function single($select) {
    if ($select) {
      foreach ($select as $single) {
        return $single;
      }
    }
    return $select;
  }

  public function save_img($url = false, $to = false, $force = false) {
    if ($url && $to) {
      if (!file_exists($this->_files->db_img.$to) || $force) {
        $ch = curl_init($url);
        $fp = fopen($this->_files->db_img.$to, 'wb');
        curl_setopt($ch, CURLOPT_FILE, $fp);
        curl_setopt($ch, CURLOPT_HEADER, 0);
        curl_exec($ch);
        curl_close($ch);
        fclose($fp);
        
        return 'New: '.$this->_files->db_img.$to;
      }
      return 'Old: '.$this->_files->db_img.$to;
    }
    return $this->error("Cannot Save Blank URL To Blank Location");
  }
}
?>