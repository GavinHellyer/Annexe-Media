<?php
/**
 * @ver 1.0
 * @order 30
 */
class database extends security {
  private $_db = false;
  private $_schema;
  private $_schema_bak;
  
  public function __construct() {
    parent::__construct();
    $this->defines('LOADED_DATABASE', true);
  }

  public function set_schema($schema = false) {
    if ($schema) {
      if (file_exists($this->_files->db.$schema.'.db')) {
        $this->_schema = $schema.'.db';
        $this->_schema_bak = BAKUP_DATE.'_'.$schema.'.db.bak';
        
        return $this;
      }
      return false;
    }
    return false;
  }
  
  public function open() {
    if (file_exists($this->_files->db.$this->_schema)) {
      if (file_exists("DB.php")) {
        require_once "DB.php";
        require_once "DB/sqlite.php";
      } else {
        require_once(SERVER_ROOT."include/database/DB.php");
        require_once(SERVER_ROOT."include/database/DB/sqlite.php");
        //require_once(SERVER_ROOT."include/database.php");
      }
      $dbd = array(
        'phptype'  => 'sqlite3',
        'database' => $this->_files->db.$this->_schema,
        'mode'     => '0644',
      );
      $this->_db =& DB::connect($dbd);
      if (PEAR::isError($this->_db)) {
        return $this->error($this->_db->getMessage());
      } else {
        $this->backup();
        return true;
      }
    }
    return $this->error('Schema Not Found');
  }

  private function backup() {
    if (!file_exists($this->_files->db.BAKUP_DATE.'_'.$this->_schema.'.bak')) {
      copy($this->_files->db.$this->_schema, $this->_files->db.BAKUP_DATE.'_'.$this->_schema.'.bak');
      $d = dir($this->_files->db);
      $backups = array();
      while (false !== ($entry = $d->read())) {
        if (!in_array($entry, array('.', '..'))) {
          if (substr($entry, -3) == 'bak' && strpos($entry, $this->_schema) !== false) {
            if (count($backups) >= BACKUP_LIMIT) {
              unlink($backups[count($backups)-BACKUP_LIMIT]);
            }
            $backups[] = $this->_files->db.'/'.$entry;
          }
        }
      }
      $d->close();
    }
  }
  
  public function execute($query = false, $return = true) {
    if ($query) {
      $sql =& $this->_db->query($query);

      if ($sql && PEAR::isError($sql)) {
        return $this->error($sql->getMessage()." :: ".$query);
      } else {
        if ($sql && $return) {
          $result = array();
          while ($sql->fetchInto($row, DB_FETCHMODE_ASSOC)) {
            $result[] = $row;
          }
          $sql->free();
          return $this->array_to_object($result);
        } else if (!$return) {
          return true;
        } else {
          return $this->error('Query Error: '.$query);
        }
      }
    }
    return $this->error('Missing SQL Statement');
  }

  public function select($columns, $table, $where = false, $order = false, $limit = false) {
    if (isset($this->_db)) {
      $columns = is_array($columns) ? implode(',', $columns) : $columns;
      if ($where && is_array($where) && count($where)) {
        $build = " WHERE ";
        foreach($where as $key => $val) {
          if ($build != " WHERE ") {
            $build .= " AND ";
          }
          $build .= $key." = ".$this->clean_for_db($val);
        }
        $where = $build;
      } else {
        $where = '';
      }
      if ($order && is_array($order) && count($order)) {
        $build = " ORDER BY ";
        foreach($order as $key => $val) {
          if ($build != " ORDER BY ") {
            $build .= ", ";
          }
          $build .= $key." ".$val;
        }
        $order = $build;
      } else {
        $order = '';
      }
      $limit = ($limit) ? " LIMIT ".$limit : '';

      return $this->execute("SELECT $columns FROM $table $where $order $limit");
    }
    return $this->error('DB Not Loaded');
  }

  public function insert($table, $fields) {
    if (isset($this->_db)) {
      if (is_array($fields) && count($fields)) {
        foreach($fields as $key => $val) {
          $fields[$key] = $this->clean_for_db($val);
        }
        $result = $this->execute("INSERT INTO $table (".implode(',', array_keys($fields)).") VALUES (".implode(',', array_values($fields)).")", false);
        if ($result) {
          return $this->last_insert_id();
        }
        return false;
      }
      return $this->error('Invalid Fields');
    }
    return $this->error('DB Not Loaded');
  }
  
  public function update($table, $fields, $where = false) {
    if (isset($this->_db)) {
      if (is_array($fields) && count($fields)) {
        $with = " SET ";
        foreach($fields as $key => $val) {
          if ($with != " SET ") {
            $with .= ", ";
          }
          $with .= $key." = ".$this->clean_for_db($val);
        }
        if ($where && is_array($where) && count($where)) {
          $build = " WHERE ";
          foreach($where as $key => $val) {
            if ($build != " WHERE ") {
              $build .= " AND ";
            }
            $build .= $key." = ".$this->clean_for_db($val);
          }
          $where = $build;
        } else {
          $where = '';
        }
        return $this->execute("UPDATE $table $with $where", false);
      }
      return $this->error('Invalid Fields');
    }
    return $this->error('DB Not Loaded');
  }

  private function last_insert_id() {
    return sqlite3_last_insert_rowid($this->_db->connection);
  }

  public function clean_insert($insert_fields, $clean = array()) {
    if (count($clean)) {
      foreach($clean as $key => $val) {
        if (is_array($insert_fields)) {
          unset($insert_fields[$val]);
        }
        if (is_object($insert_fields)) {
          unset($insert_fields->$val);
        }
      }
    }

    return $insert_fields;
  }

  public function clean_for_db($string, $encase = "'") {
    return $encase.str_replace("'", "&#44;", $string).$encase;
  }

  public function single($select) {
    if ($select) {
      foreach ($select as $single) {
        return $single;
      }
    }
    return $select;
  }
}
?>